import { mapCvssToSeverity, sortBySeverity } from '../utils/severityMapper.js';

/**
 * Extract genuine (reachable) vulnerabilities after filtering out false positives
 * @param {Object} owaspData - Parsed OWASP report data
 * @param {Array} falsePositives - Array of identified false positives
 * @returns {Array} Array of true vulnerability findings
 */
export async function extractVulnerabilities(owaspData, falsePositives) {
    const fpCveIds = new Set(falsePositives.map(fp => fp.cve_id));

    const trueVulnerabilities = [];

    for (const vuln of owaspData.vulnerabilities) {
        // Skip if this CVE was identified as a false positive
        if (fpCveIds.has(vuln.cveId)) {
            continue;
        }

        const extracted = {
            cve_id: vuln.cveId,
            dependency: formatDependency(vuln.dependency, vuln.version),
            severity: vuln.severity || mapCvssToSeverity(vuln.cvssScore),
            cvss_score: vuln.cvssScore || 0,
            description: vuln.description || getDefaultDescription(vuln),
            recommended_fix: generateRecommendedFix(vuln),
            references: vuln.references || [],
            affected_versions: extractAffectedVersions(vuln),
            source: vuln.source || 'NVD'
        };

        trueVulnerabilities.push(extracted);
    }

    // Sort by severity (most severe first)
    return sortBySeverity(trueVulnerabilities);
}

/**
 * Format dependency with version
 */
function formatDependency(dependency, version) {
    if (version && version !== 'Unknown') {
        return `${dependency}@${version}`;
    }
    return dependency;
}

/**
 * Generate a default description if none provided
 */
function getDefaultDescription(vuln) {
    const severity = vuln.severity || mapCvssToSeverity(vuln.cvssScore);
    return `${severity} severity vulnerability detected in ${vuln.dependency}. CVE: ${vuln.cveId}. CVSS Score: ${vuln.cvssScore || 'Unknown'}.`;
}

/**
 * Generate recommended fix based on vulnerability info
 */
function generateRecommendedFix(vuln) {
    const fixes = [];

    // Primary recommendation: upgrade
    fixes.push(`Upgrade ${extractPackageName(vuln.dependency)} to the latest patched version.`);

    // Check vulnerability type from description for specific guidance
    const desc = (vuln.description || '').toLowerCase();

    if (desc.includes('remote code execution') || desc.includes('rce')) {
        fixes.push('CRITICAL: This vulnerability allows remote code execution. Prioritize immediate patching.');
    }

    if (desc.includes('denial of service') || desc.includes('dos')) {
        fixes.push('Consider implementing rate limiting and resource constraints as temporary mitigation.');
    }

    if (desc.includes('sql injection')) {
        fixes.push('Ensure all database queries use parameterized statements.');
    }

    if (desc.includes('xss') || desc.includes('cross-site scripting')) {
        fixes.push('Implement proper output encoding and Content Security Policy headers.');
    }

    if (desc.includes('prototype pollution')) {
        fixes.push('Avoid using user input directly in object property assignments.');
    }

    if (desc.includes('path traversal') || desc.includes('directory traversal')) {
        fixes.push('Validate and sanitize file paths. Use allowlists for file access.');
    }

    // If no version info, add general guidance
    if (!vuln.version || vuln.version === 'Unknown') {
        fixes.push('Review dependency version and compare against known patched versions.');
    }

    // Add reference to CVE
    fixes.push(`See https://nvd.nist.gov/vuln/detail/${vuln.cveId} for more information.`);

    return fixes.join(' ');
}

/**
 * Extract affected version range from vulnerability data
 */
function extractAffectedVersions(vuln) {
    const affected = [];

    if (vuln.vulnerableSoftware && Array.isArray(vuln.vulnerableSoftware)) {
        for (const software of vuln.vulnerableSoftware) {
            if (typeof software === 'string') {
                // Parse CPE format
                const versionMatch = software.match(/:(\d+\.\d+[\w.-]*)/);
                if (versionMatch) {
                    affected.push(versionMatch[1]);
                }
            } else if (software && software.versionEndIncluding) {
                affected.push(`<= ${software.versionEndIncluding}`);
            } else if (software && software.versionEndExcluding) {
                affected.push(`< ${software.versionEndExcluding}`);
            }
        }
    }

    if (affected.length === 0 && vuln.version) {
        affected.push(vuln.version);
    }

    return affected;
}

/**
 * Extract package name from dependency string
 */
function extractPackageName(dependency) {
    if (!dependency) return 'the affected package';

    let name = dependency.replace(/\.(jar|war|zip|tar\.gz|tgz|whl|egg)$/i, '');

    if (name.includes(':')) {
        const parts = name.split(':');
        if (parts.length >= 2) return parts[1];
    }

    if (name.includes('@') && !name.startsWith('@')) {
        name = name.split('@')[0];
    }

    const versionPattern = /-\d+\.\d+(\.\d+)?([.-][\w.]+)?$/;
    name = name.replace(versionPattern, '');

    return name;
}

/**
 * Group vulnerabilities by dependency
 * @param {Array} vulnerabilities - Array of vulnerabilities
 * @returns {Object} Vulnerabilities grouped by dependency name
 */
export function groupByDependency(vulnerabilities) {
    const grouped = {};

    for (const vuln of vulnerabilities) {
        const depName = extractPackageName(vuln.dependency);

        if (!grouped[depName]) {
            grouped[depName] = [];
        }

        grouped[depName].push(vuln);
    }

    return grouped;
}

/**
 * Get summary statistics for vulnerabilities
 * @param {Array} vulnerabilities - Array of vulnerabilities
 * @returns {Object} Statistics summary
 */
export function getVulnerabilityStats(vulnerabilities) {
    const stats = {
        total: vulnerabilities.length,
        critical: 0,
        high: 0,
        medium: 0,
        low: 0,
        unknown: 0
    };

    for (const vuln of vulnerabilities) {
        const severity = (vuln.severity || 'UNKNOWN').toUpperCase();
        if (stats.hasOwnProperty(severity.toLowerCase())) {
            stats[severity.toLowerCase()]++;
        } else {
            stats.unknown++;
        }
    }

    return stats;
}
